# encoding: UTF-8

module DryCrud

  # The query functionality for the index table, implemented using Arel (part of Active Record)
  # @see https://github.com/rails/arel
  # @see http://rdoc.info/github/rails/arel/Arel
  # @see http://www.slideshare.net/flah00/activerecord-arel
  # @see http://radar.oreilly.com/2014/03/just-enough-arel.html
  # @see http://radar.oreilly.com/2014/05/more-than-enough-arel.html
  # @see http://erniemiller.org/2010/03/28/advanced-activerecord-3-queries-with-arel/
  # @see http://erniemiller.org/2010/05/11/activerecord-relation-vs-arel/
  # @see http://guides.rubyonrails.org/active_record_querying.html
  # @see http://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html
  # @see http://www.skorks.com/2010/05/what-every-developer-should-know-about-urls/
  module Queryable
    extend ActiveSupport::Concern

    included do

      class_attribute :default_sort

      alias_method_chain :list_entries, :query
    end

    private

    # Modifies the ActiveRecord::Relation object generated by app/controllers/list_controller#list_entries
    # Uses ActiveRecord::QueryMethods verbs with Arel arguments to specify the subset and rendering of data to return
    # @return [ActiveRecord::Relation]
    def list_entries_with_query
      ar_query = list_entries_without_query
      ar_query = ar_query.where(arel_condition) if params[:where]
      if params[:format] == 'json'
        # make sure we don't ask for entire table
        params[:limit] ||= 10
        if params[:select]
          selected_columns = arel_select_columns
          ar_query = ar_query.select(selected_columns)
          attribute_columns = arel_attribute_columns(selected_columns)
          if attribute_columns.size < selected_columns.size
            # doing aggregation of some sort
            unless attribute_columns.empty?
              # need to specify grouping and sort order
              ar_query = ar_query.group(attribute_columns)
              ar_query = ar_query.order(attribute_columns)
            end
          else
            ar_query = ar_query.order(arel_order) # use params[:order] else default sort order
          end
        end
        ar_query = ar_query.offset(params[:offset].to_i) if params[:offset]
        ar_query = ar_query.limit(params[:limit].to_i) if params[:limit]
      else
        ar_query = ar_query.order(arel_order) # uses params[:order] else default sort order
        raise "Query select option is not supported in table mode" if params[:select]
        raise "Query offset option is not supported in table mode" if params[:offset]
        raise "Query limit option is not supported in table mode" if params[:limit]
      end
      ar_query
    end


    # A representation of the model's table structure.
    # An Arel::Table object acts like a hash that contains all columns of the table
    # @see http://rdoc.info/github/rails/arel/Arel/Table
    # @return [Arel::Table]
    def table
      model_class.arel_table
    end

    # Parses the *select* param of the URI containing column names and optional aggregation expressions
    #   (average, count, minimum, maximum, or sum), generating objects that represent those
    #   columns or expressions.
    # @see http://rdoc.info/github/rails/arel/Arel/Attributes/Attribute
    # @see http://rdoc.info/github/rails/arel/Arel/Expressions
    # @return [Array<Arel::Attributes::Attribute,Arel::Expressions>]
    def arel_select_columns
      select_columns = params[:select].split(' ')
      display_columns = select_columns.map do |column|
        column_spec = column.split('.')
        name, aggregation, distinct = column_spec
        case column_spec.size
          when 1
            # simple column name
            table[name]
          when 2
            # column name and aggregation keyword
            expressions = %w{average count minimum maximum sum}
            raise "Illegal aggregation: #{aggregation} in #{column}" unless expressions.include?(aggregation)
            table[name].send(aggregation).as("#{aggregation}_#{name}")
          when 3
            # column name, aggregation keyword, and distinct keyword
            raise "Unrecognized aggregate modifier: #{distinct} in #{column}" unless (distinct == 'distinct')
            table[name].send(aggregation,true).as("#{aggregation}_d_#{name}")
        end
      end
      display_columns
    end

    # Filters the *selected_columns* array, and returns Attributes (columns) that do not specify aggregations
    # @param [Array] selected_columns The columns that will be displayed in the result
    # @return [Array<Arel::Attributes::Attribute>]
    def arel_attribute_columns(selected_columns)
      group_columns = selected_columns.select{|column| column.is_a?(Arel::Attributes::Attribute)}
      group_columns
    end

    # Parses the *where* param of the URI, using predicate and boolean logic
    #   to consolidate the condition into a single node object
    # @see http://rdoc.info/github/rails/arel/Arel/Nodes/Node
    # @return [Arel::Nodes::Node]
    def arel_condition
      nested_string_array = parse_where_param
      condition = arel_condition_node(nested_string_array, top_level=true)
      condition
    end

    # Converts the string extracted from the URI into an Array of strings based on the ~ delimiter
    # Any parentheses encountered are converted into a nested array structure in order to support complex queries
    # @see http://stackoverflow.com/questions/38409/how-do-i-convert-a-ruby-string-with-brackets-to-an-arra
    # @return [Array<String,Array>]
    def parse_where_param
      string = params[:where]
      # => "((c1)~or~(c2))~and~((d1)~or~(d2))"
      yaml = '[' + string.gsub('(', '[').gsub(')', ']').gsub('~', ', ').gsub(':','&colon;') + ']'
      # => "[[[c1], or, [c2]], and, [[d1], or, [d2]]]"
      array = YAML.load yaml
      # => [[["c1"], "or", ["c2"]], "and", [["d1"], "or", ["d2"]]]
      array = array.first while array.first.is_a?(Array) and array.size == 1
      # in case top level is nested too deep
      array
    end

    # Recursively convert a nested array of strings into Arel nodes, reducing the whole into a single node
    # @param [String,Array] token A portion of the condition that will be condensed into a node.
    #   Each token is either a string or an array of other tokens
    # @param [Object] top_level Indicates whether we are at the top level of the nested arrays
    #   (because we don't need to wrap the top level in a grouping node)
    # @return [Arel::Nodes::Node]
    def arel_condition_node(token, top_level=false)
      unless token.is_a?(String) or token.is_a?(Array)
        return "token must be String or Array: #{token.inspect}"
      end
      result = if token.is_a?(String)
                 arel_predicate_node(token)
               elsif token.size == 1
                 # recurse
                 arel_condition_node(token.first, top_level)
               elsif top_level
                 arel_compound_predicate(token)
               else
                 arel_grouping_node(token)
               end
      result
    end

    # Convert the input string into an Arel Node that represents the column,value comparison to be performed
    # @see http://rubydoc.info/github/rails/arel/master/Arel/Predications
    # @see http://rdoc.info/github/rails/arel/Arel/Nodes/Node
    # @param [String] predicate_string A string of the form: left~operator~right representing a predicate
    # @return [Arel::Nodes::Predications]
    def arel_predicate_node(predicate_string)
      column_name, operator, value = parse_predicate(predicate_string)
      value.gsub!('&colon;',':')
      value = value.split(' ') if operator.include?('in')
      node = table[column_name].send(operator, value)
      node
    end

    # Split the string representation of a predicate into an array of strings, then verify the result
    # @see http://www.jacopretorius.net/2012/01/splat-operator-in-ruby.html
    # @param [String] predicate_string A string of the form: left~operator~right representing a predication
    # @return [Array<String>]
    def parse_predicate(predicate_string)
      array = predicate_string.split('.', 3)
      raise "Predicate does not have 3 members: #{predicate_string}" unless array.size == 3
      column_name, operator, value = array
      @columns = self.permitted_attrs
      raise "Unrecognized column name #{column_name}" unless @columns.include?(column_name.to_sym)
      @comparison_operators ||= %w{eq gt gteq in lt lteq matches not_eq not_in}
      raise "Operator not recognised in predicate: #{predicate_string}" unless @comparison_operators.include?(operator)
      array
    end

    # Rercursively combine simpler Arel predicate nodes into a single condition node.
    #   The recursion occurs by using the *arel_condition_node* method to reduce the non-boolean array members
    # @param [Array<String>] string_array An array of strings representing predicates and boolean operators
    # @return [Arel::Nodes::Node]
    def arel_compound_predicate(string_array)
      @boolean_operators ||= %w{and or not}
      # make a pass through the array, replacing non-boolean strings with Arel nodes
      node_array = string_array.map { |s| @boolean_operators.include?(s) ? s : arel_condition_node(s) }
      # reduce 'not',node pairs into Arel::Nodes::Not nodes
      node_array_2 = apply_negation_nodes(node_array)
      # reduce left,boolean,right,... sequences into Arel::Nodes::And or Arel::Nodes::Or
      result = apply_boolean_nodes(node_array_2)
      result
    end

    # Reduce 'not',node pairs into Arel::Nodes::Not nodes
    # @param [Array<Arel::Nodes::Node,String] input_array
    # @return [Array<Arel::Nodes::Node,String]
    def apply_negation_nodes(input_array)
      return input_array unless input_array.include?('not')
      last_index = input_array.size - 1
      output_array = Array.new
      i = 0
      while i < input_array.size
        if input_array[i] == 'not'
          raise "Illegal 'not' operator at end of compound predicate: #{params[:where]}" if i == last_index
          i += 1
          operand = input_array[i]
          raise "Can only negate a condition node: #{params[:where]}" unless operand.is_a?(Arel::Nodes::Node)
          output_array << Arel::Nodes::Not.new(operand)
        else
          output_array << input_array[i]
        end
        i += 1
      end
      output_array
    end

    # Repeatedly reduce left,boolean,right,... sequences into Arel::Nodes::And or Arel::Nodes::Or
    # @param [Array<Arel::Nodes::Node,String] input_array
    # @return [Arel::Nodes::Node]
    def apply_boolean_nodes(input_array)
      last_index = input_array.size - 1
      return input_array.first if last_index < 1
      result = nil
      i = 0
      while i < last_index
        left = result || input_array[0]
        raise "Invalid boolean syntax: #{params[:where]}" unless left.is_a?(Arel::Nodes::Node)
        i += 1
        bool = input_array[i]
        raise "Invalid boolean syntax: #{params[:where]}" unless @boolean_operators.include?(bool)
        i += 1
        right = input_array[i]
        raise "Invalid boolean syntax: #{params[:where]}" unless right.is_a?(Arel::Nodes::Node)
        result = case input_array[1]
                   when 'and'
                     Arel::Nodes::And.new(input_array[0], input_array[2])
                   when 'or'
                     # noinspection RubyArgCount
                     Arel::Nodes::Or.new(input_array[0], input_array[2])
                 end
      end
      result
    end

    # Wrap the condition token in a Arel::Nodes::Grouping envelope
    # For oracle queries, AND has precedence over OR, unless parentheses are used to control grouping
    # The arel_table's 'grouping' method can used to create a Arel::Nodes::Grouping node which
    # will will generate grouping parentheses in the SQL that is generated
    # @example
    #   table = Person.arel_table
    #   pred1 = table[:forename].eq("Richard").and(table[:town].eq("London"))
    #   pred2 = table[:forename].eq("Rick").and(table[:town].eq("US"))
    #   pt.grouping(pred1).or(pt.grouping(pred2)).to_sql
    #   => (("people"."forename" = 'Richard' AND "people"."town" = 'London') OR ("people"."forename" = 'Rick' AND "people"."town" = 'US'))
    # @see http://docs.oracle.com/cd/E17952_01/refman-5.1-en/operator-precedence.html
    # @see http://rubydoc.info/github/rails/arel/Arel/FactoryMethods#grouping-instance_method
    # @see http://www.coderexception.com/03B66b6mHSxPXJUW/railsarel-precedence-when-combining-arel-predicates
    # @see http://stackoverflow.com/questions/6523810/rails-arel-precedence-when-combining-arel-predicates
    # @see http://rubydoc.info/github/rails/arel/Arel/Nodes/Grouping
    # @return [Arel::Nodes::Grouping]
    # @param [Array<String,Array>] token A set of predicates that should be surrounded by parentheses in SQL
    def arel_grouping_node(token)
      Arel::Nodes::Grouping.new(arel_compound_predicate(token))
    end

    # Specify the sort order for the results, either by parsing *order* param,
    # or figuring out default from the Model
    # @return [Array<Arel::Attributes::Attribute>]
    def arel_order
      text_columns = if params[:order]
                       params[:order].split(' ')
                     elsif self.default_sort
                       [self.default_sort].flatten
                     else
                       [model_class.primary_key].flatten
                     end
      sort_columns = text_columns.map do |column|
        if column.to_s.include?('.')
          name,direction = column.to_s.split('.',2)
          raise "Illegal sort direction: #{direction} in #{column}" unless %w{asc desc}.include?(direction)
          table[name].send(direction)
        else
          table[column]
        end
      end
      sort_columns
    end

  end
end
